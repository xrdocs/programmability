---
published: true
date: '2021-02-04 18:20 +0100'
title: pyATS series - Parsing like a pro
author: Antoine Orsoni
excerpt: Explore pyATS libraries and parse your first CLI output
tags:
  - iosxr
  - cisco
  - pyATS
position: hidden
---
{% include toc icon="table" title="Table of Contents" %}
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style type="text/css">
/*
generated by Pygments <https://pygments.org/>
Copyright 2006-2020 by the Pygments team.
Licensed under the BSD license, see LICENSE for details.
*/
pre { line-height: 125%; margin: 0; font-size: small; }
td.linenos pre { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
span.linenos { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
td.linenos pre.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
body .hll { background-color: #ffffcc }
body { background: #f8f8f8; }
body .c { color: #008800; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #AA22FF; font-weight: bold } /* Keyword */
body .o { color: #666666 } /* Operator */
body .ch { color: #008800; font-style: italic } /* Comment.Hashbang */
body .cm { color: #008800; font-style: italic } /* Comment.Multiline */
body .cp { color: #008800 } /* Comment.Preproc */
body .cpf { color: #008800; font-style: italic } /* Comment.PreprocFile */
body .c1 { color: #008800; font-style: italic } /* Comment.Single */
body .cs { color: #008800; font-weight: bold } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #AA22FF; font-weight: bold } /* Keyword.Constant */
body .kd { color: #AA22FF; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #AA22FF; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #AA22FF } /* Keyword.Pseudo */
body .kr { color: #AA22FF; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #00BB00; font-weight: bold } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BB4444 } /* Literal.String */
body .na { color: #BB4444 } /* Name.Attribute */
body .nb { color: #AA22FF } /* Name.Builtin */
body .nc { color: #0000FF } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #00A000 } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #B8860B } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mb { color: #666666 } /* Literal.Number.Bin */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sa { color: #BB4444 } /* Literal.String.Affix */
body .sb { color: #BB4444 } /* Literal.String.Backtick */
body .sc { color: #BB4444 } /* Literal.String.Char */
body .dl { color: #BB4444 } /* Literal.String.Delimiter */
body .sd { color: #BB4444; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BB4444 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BB4444 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BB4444 } /* Literal.String.Single */
body .ss { color: #B8860B } /* Literal.String.Symbol */
body .bp { color: #AA22FF } /* Name.Builtin.Pseudo */
body .fm { color: #00A000 } /* Name.Function.Magic */
body .vc { color: #B8860B } /* Name.Variable.Class */
body .vg { color: #B8860B } /* Name.Variable.Global */
body .vi { color: #B8860B } /* Name.Variable.Instance */
body .vm { color: #B8860B } /* Name.Variable.Magic */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
</head>
![pyats_hello2.jpg]({{site.baseurl}}/images/pyats_hello2.jpg){: .align-center}

# pyATS overview

Ever dreamed of a test framework that could be used across multiple platforms, OS and vendors, which could do regression, sanity and feature testing; already used by thousands of engineers and developers worldwide? Guess what, **it exists, it’s free, and you can start using it right now!**

pyATS (**Py**thon **A**utomated **T**est **S**ystems, to be pronounced "py A. T. S.") was first created as an internal project, to ease the validation of two OS versions. It has been made public in 2017 through **Cisco Devnet**.

This blog post will be the second one of a series on pyATS. Today, we will explore pyATS libraries (also known as Genie), and we will collect our first **parsed output**. More use cases are going to be covered in the next posts. 

# Other pyATS episodes

You've missed the first episode? You would like to read more? Below the list of published episodes:

| Episode 	| URL                                                                                              	| What's covered                                        	|
|---------	|--------------------------------------------------------------------------------------------------	|-------------------------------------------------------	|
| **1 - Install and use pyATS**       	| [Link](https://xrdocs.io/programmability/tutorials/pyats-series-install-and-use-pyats/){: .btn}  	|  What's pyATS, Install pyATS, Collect a raw CLI output 	|
| **2 - Parsing like  a pro**       	| [Link](https://xrdocs.io/programmability/tutorials/2021-02-04-pyats-series-parsing-like-a-pro-with-genie/){: .btn} 	|  Explore pyATS libraries, Collect and parse a CLI output        	|

# pyATS librairies overview

## pyATS building blocks

pyATS is made of three main building blocks:
- **pyATS**, the core block of this ecosystem. It’s a Python framework which leverages multiple Python libraries such as [Unicon](https://pypi.org/project/unicon/), providing a simplified connection experience to network devices. It supports **CLI**, **NETCONF** and **RESTCONF**. It enables network engineers and developers to start with small and simple test cases.
- **pyATS libraries** (also known as Genie) which provides everything you need for network testing such as parsers, triggers and APIs. 
- **XPRESSO**, the pyATS Web UI Dashboard.

You can read more about **pyATS ecosystem** in the [official documentation](https://pubhub.devnetcloud.com/media/pyats-getting-started/docs/intro/introduction.html).
{: .notice--info}

**pyATS libraries** are the pyATS **SDK** (**S**oftware **D**evelopment **K**it, a big toolbox) which contains all the tools that you need for **Network Test Automation**. It has been used internally at Cisco since 2010 for our automated testing. Yes! You can use the same tools that we use to automate the validation of your network.

You can read more about **pyATS librairies** in the [official documentation](https://developer.cisco.com/docs/genie-docs/).
{: .notice--info}

## pyATS libraries in a nutshell

* **1200** parsers accross 11 OS (as of February 2021),
* **32** supported models (more to come about them in a coming episode),
* Multiple tools for Test Harness such as triggers or traffic,
* Ansible and Robot libraries for easy integration with other tools.


You can find supported **parsers** and **models** in the [official documentation](https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/).
{: .notice--info}

# Getting your hands dirty

Enough talking, let's code!

![keyboard cat_small2.png]({{site.baseurl}}/images/keyboard cat_small2.png){: .align-center}

**pyATS installation** has been covered in the [First episode](https://xrdocs.io/programmability/tutorials/pyats-series-install-and-use-pyats/). Check it out to learn how to install pyATS.

## Parsing a CLI output from a device

In this first use case, we saw how we can get a **simple CLI output** (`show ip interface brief`) from an IOS XR device. 

In this second use case, we are going to see how we can **collect and parse a CLI output** (`show ip interface brief`).

In order for everyone to be able to run the code, we will use the [IOS XR always-on sandbox on Cisco Devnet](https://devnetsandbox.cisco.com/RM/Diagram/Index/e83cfd31-ade3-4e15-91d6-3118b867a0dd?diagramType=Topology). Feel free to adapt the code to use your own device(s). Below the sandbox information.

| Key               	| Value                    	|
|-------------------	|--------------------------	|
| IOS XRv 9000 host 	| sbx-iosxr-mgmt.cisco.com 	|
|     SSH Port      	|     8181                 	|
|     Username      	|     admin                	|
|     Password      	|     C1sco12345           	|

## Building a testbed

The simplest way to connect to a device is through a pyATS testbed file, written in YAML. This information will be used by **Unicon** to connect to the device and send the requested commands.

You can find the complete documentation on how to build a testbed [here](https://pubhub.devnetcloud.com/media/unicon/docs/user_guide/connection.html).
{: .notice--info}

**testbed.yaml**
{: .notice--primary}
<div class="highlight"><pre><span></span><span class="c1"># Step 0: list of devices</span>
<span class="nt">devices</span><span class="p">:</span>
  <span class="nt">iosxr1</span><span class="p">:</span>
    <span class="c1"># Step 1: OS and Type</span>
    <span class="nt">type</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">iosxr-devnet</span>
    <span class="nt">os</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">iosxr</span>
    <span class="c1"># Step 2: credentials</span>
    <span class="nt">credentials</span><span class="p">:</span>
      <span class="nt">default</span><span class="p">:</span>
        <span class="nt">username</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">admin</span>
        <span class="nt">password</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">C1sco12345</span>
    <span class="c1"># Step 3: connection parameters</span>
    <span class="nt">connections</span><span class="p">:</span>
      <span class="nt">vty</span><span class="p">:</span>
        <span class="nt">protocol</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ssh</span>
        <span class="nt">ip</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">sbx-iosxr-mgmt.cisco.com</span>
        <span class="nt">port</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">8181</span>
</pre></div>

The `testbed.yaml` file is available [here](https://github.com/AntoineOrsoni/xrdocs-how-to-pyats/blob/master/1_parsed_output/).
{: .notice--info}

The **testbed construction** has been covered in the [First episode](https://xrdocs.io/programmability/tutorials/pyats-series-install-and-use-pyats/). Have a look to understand how to build a testbed from scratch

## Raw output vs Parsed output

Now, you know how to get a CLI output using pyATS. Getting a specific information in this big text output is easy for a human; but what about a computer? You got it, that's the power of the **pyATS libraries**: converting this **raw output** (string) into a **parsed output** (dictionary) where you can easily get a value by accessing a specific key.

![raw_parsed_output_small.png]({{site.baseurl}}/images/raw_parsed_output_small.png){: .align-center}

Let's take an example. Below the CLI output you would get by typing `show ip interface brief`. 

**Raw CLI output**
{: .notice--primary}
<div class="highlighter-rouge">
<pre class="highlight">
<code>
Interface                      IP-Address      Status          Protocol Vrf-Name
Loopback100                    1.1.1.100       Up              Up       default 
Loopback200                    1.1.1.200       Down            Down     Red 
</code>
</pre>
</div>

And now, the same output, of the same CLI command `show ip interface brief`, parsed with pyATS libraries. Note that you can see the **exact same information** compared to the raw output above. Nothing more, nothing less.

**Parsed CLI output**
{: .notice--primary}
<div class="highlighter-rouge">
<pre class="highlight">
<code>
{
    "interface": {
        "Loopback100": {
            "ip_address": "1.1.1.100",
            "interface_status": "Up",
            "protocol_status": "Up",
            "vrf_name": "default",
        },
        "Loopback200": {
            "ip_address": "1.1.1.200",
            "interface_status": "Down",
            "protocol_status": "Down",
            "vrf_name": "Red",
        }
}
</code>
</pre>
</div>

## Collecting and parsing your first CLI output with pyATS libraries

Now that we understand the difference between a **raw output** (a string) and a **parsed output** (a dictionary), let's look at the code. This script will collect a parsed output of the `show ip interface brief` command. It will extract the interface `name` and the interface `ip address` from the dictionary, then print each couple. The script  will be further detailed and explained below.

**1_parsed_output.py**
{: .notice--primary}
<div class="highlight"><pre><span></span><span class="c1"># New module! Now using Genie!</span>
<span class="kn">from</span> <span class="nn">genie</span> <span class="kn">import</span> <span class="n">testbed</span>

<span class="c1"># Step 0: load the testbed</span>
<span class="n">testbed</span> <span class="o">=</span> <span class="n">testbed</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;./testbed.yaml&#39;</span><span class="p">)</span>

<span class="c1"># Step 1: testbed is a dictionary. Extract the device iosxr1</span>
<span class="n">iosxr1</span> <span class="o">=</span> <span class="n">testbed</span><span class="o">.</span><span class="n">devices</span><span class="p">[</span><span class="s2">&quot;iosxr1&quot;</span><span class="p">]</span>

<span class="c1"># Step 2: Connect to the device</span>
<span class="n">iosxr1</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">init_exec_commands</span><span class="o">=</span><span class="p">[],</span> <span class="n">init_config_commands</span><span class="o">=</span><span class="p">[],</span> <span class="n">log_stdout</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Step 3: saving the `show ip interface brief` output in a variable</span>
<span class="n">show_interface</span> <span class="o">=</span> <span class="n">iosxr1</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;show ip interface brief&#39;</span><span class="p">)</span>

<span class="c1"># Step 4: iterating through the parsed output. Extracting interface name and IP</span>
<span class="k">for</span> <span class="n">interface</span> <span class="ow">in</span> <span class="n">show_interface</span><span class="p">[</span><span class="s1">&#39;interface&#39;</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">interface</span><span class="si">}</span><span class="s2"> -- </span><span class="si">{</span><span class="n">show_interface</span><span class="p">[</span><span class="s1">&#39;interface&#39;</span><span class="p">][</span><span class="n">interface</span><span class="p">][</span><span class="s1">&#39;ip_address&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Step 5: disconnect from the device</span>
<span class="n">iosxr1</span><span class="o">.</span><span class="n">disconnect</span><span class="p">()</span>
</pre></div>

The `1_parsed_output.py` file is available [here](https://github.com/AntoineOrsoni/xrdocs-how-to-pyats/blob/master/1_parsed_output/).
{: .notice--info}

### Executing the script

**From your bash terminal**
{: .notice--primary}
<div class="highlighter-rouge">
<pre class="highlight">
<code>
python 1_parsed_output.py
</code>
</pre>
</div>

In this example, the `testbed.yaml` file need to be in the same folder as the `1_parsed_output.py` file. Also, you need to execute the Python script in the folder where you have these two files.
{: .notice--info}

Let's now explain the building blocks of the Python script. The parts below will refer to each inline comment of the code block above.

### Output example

Here is an output example of the above script. It might slightly vary according to the configuration of the device.

**Python console**
{: .notice--primary}
<div class="highlighter-rouge">
<pre class="highlight">
<code>
Loopback333 -- 3.3.3.3
Loopback99 -- 99.99.99.99
Loopback11 -- 1.2.3.1
GigabitEthernet2 -- Unassigned
GigabitEthernet1 -- 10.10.20.48
GigabitEthernet3 -- Unassigned
</code>
</pre>
</div>

### Step 0: load the testbed

From the `genie` module, we import the `testbed.load()` function. This function will be used to load the testbed file we have created.

We load the `testbed` information, stored in our `testbed.yaml` file. We assign it to an object: `testbed`.

### Step 1: extract device information

`testbed` is a Python dictionary. We are extracting the device `iosxr1` information. We assign it to an object: `iosxr1`.

You can name the object with the name you want. The object name does not need to match the hostname of you device.
{: .notice--info}

### Step 2: connect to the device

We use the `connect()` method on the `iosxr1` object to connect to the device.

By default, pyATS will send exec and configuration commands to the device (such as `terminal length 0` and `show version`). To avoid such behavior, we are passing arguments to the `conect()` method. We are also disabling the logging to standard output.
More information in the [documentation].(https://pubhub.devnetcloud.com/media/unicon/docs/user_guide/connection.html)
{: .notice--info}

### Step 3: save the `"show ip interface brief"` output in a variable

This step is the most important step in our script. It will collect the `show ip interface brief` output and parse it. Each information of the CLI output will be mapped either as a dictionary key or a value. There should be no entropy loss between the raw CLI output and the parsed output.

To do so, we are using the `parse()` method on the `device` object. The parse method takes a string as parameter, which is the IOS XR command we would like to collect and parse. We are saving this parsed output in a variable `show_interface`.

You can find all available pyATS parsers in the [documentation].(More information in the [documentation](https://pubhub.devnetcloud.com/media/unicon/docs/user_guide/connection.html).
{: .notice--info}

A parsed output example (i.e. the dictionary saved in the variable `show_interface`) can be seen in **Step 4**. 

# Step 4: Python logic to print interface name and IP

Below an example of parsed output for the `show ip interface brief` command. Most interfaces are **missing**, for conciseness.

**Parsed CLI output**
{: .notice--primary}
<div class="highlighter-rouge">
<pre class="highlight">
<code>
{
    "interface": {
        "Loopback100": {
            "ip_address": "1.1.1.100",
            "interface_status": "Up",
            "protocol_status": "Up",
            "vrf_name": "default",
        },
        "Loopback200": {
            "ip_address": "1.1.1.200",
            "interface_status": "Down",
            "protocol_status": "Down",
            "vrf_name": "Red",
        }
}
</code>
</pre>
</div>

In the above output, we have a list of interfaces: `Loopback100` and `Loopback200`. We are iterating through this list. For each interface, we are accessing the `ip_address` value. We're then printting the interface `name` and `IP`. 

It might not be useful in a real life use case. Goal here is to take a concise example, to show how easy it is to extract values of a CLI output when parsed with pyATS libraries.
{: .notice--info}

### Step 5: disconnect from the device

We use the `disconnect()` method to properly disconnect from the device. 

It’s important to properly disconnect from the device, otherwise the vty connection will remain open on the device, until it times out.
{: .notice--info}

# Conclusion

In this second episode of the pyATS series, we learnt:

- The difference between a raw and parsed output,
- Why pyATS libraries are powerful,
- How to collect and parse a CLI output from a device,
- How to get a value from a parsed output.

In the next post, we will learn what's a **Model**, why it's powerful when parsing from multiple OS at once and how to use them.

The code used for each blog post can be found [here](https://github.com/AntoineOrsoni/xrdocs-how-to-pyats). This link will include the code for all posts.
{: .notice--info}

# Resources

Below a few useful pyATS resources.

- [List of supported pyATS parsers](https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/)
- [The official pyATS documentation](https://pubhub.devnetcloud.com/media/pyats/docs/getting_started/index.html),
- [List of Unicon supported platforms](https://pubhub.devnetcloud.com/media/unicon/docs/user_guide/supported_platforms.html),
- [Devnet code exchange](https://developer.cisco.com/codeexchange/),
- [Join the Webex space with the pyATS community](https://eurl.io/#r18UzrQVr).
